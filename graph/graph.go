package algs
import (
	"fmt"
	"strconv"
	"strings"
	"math"
)

//сетевая структура данных, состоит из вершин/узлов и рёбер/связей G=(V,E) v - вершины, g - ребра
//смежные вершины - соединены 1 ребром, инцидентное ребро - имеет общую вершину с другим ребром
//мультиграф - 2 вершины соединены 2 и более ребрами, кратность ребра - сколькими ребрами соединены вершины
//псевдограф - допускаются петли(линии, начинающиеся и заканчивающиеся в 1 и той же вершине) и кратные ребра
//гиперграф - ребра может связывать произвольное количество вершин, гиперребро
//конечный граф - все множества элементов конечны
//нулевой граф или несвязный - без ребер
//ориентированные графы - начальные и конечные вершины, а ребра - дуги
//ориентированный мультиграф - два узла могут быть соединены кратными ребрами противоположного направления
//смешанный граф - ориентированные и неориентированные дуги, не используются кратные дуги одного направления, может быть петля - ориентированный псевдограф
//степень вершины - количество ребер, связанных с данной вершиной
//правильный граф - степени всех вершин равны
//в организованном графе - исходящая степень вершины - количество выходящих из вершины ребер, входящая степень - кол-во входящих ребер
//максимальное количество ребер в простом(отсутствуют петли и кратные ребра) графе - n*(n-1)/2, n - кол-во вершин
//в конечном неориентированном графе сумма всех степеней вершин = удвоенному кол-ву ребер
//каждый граф имеет четное число нечетных вершин(вершина с нечетной степенью)
//формула для суммы степеней вершин правильного графа 2*m=k*n(m - кол-во ребер, n - кол-во вершин, k - степень каждой вершины)
//двудольный граф G=(V,E) - мн-во вершин V можно разбить на 2 непересекающихся подмн-ва u и v так, что каждое ребро их мн-ва Е соединяет вершины из разных подмн-в


//матрица смежности - квадратная размером n*n
//элемент матрицы с координатами i, j указывает на то, являются ли смежными соответствующие вершины, соединены - 1, иначе - 0
//в мультиграфе кратные ребра суммируются
//в псевдографе где петля стоит 2 - петля считается за 2 ребра
//для ориентированного графа - не симметричная матрица, считаем только выходящие из вершины дуги

//матрица инцидентности
//учитываются и вершины и ребра, если вершина инцидентна ребру - 1 в ячейке, столбцы - ребра, строки - вершины
//по кол-ву единиц в строке можно определить степень вершины
//мультиграф - дублируем столбцы
//псевдограф - добавляем столбец для петли, значение 2 т к считаем концы, а не ребра
//орграф - дуга выходит из вершины -> 1, -1 <- вершина конец дуги
//список смежности - с какими вершинами смежна данная вершина
//явное задание графа - каждое ребро задается парой инцидентных ему вершин
//список ребер


//обход в глубину dfs, O(V+E) - граф представлен словарем смежности
func Dfs(graph map[string][]string, start string, visited map[string]bool, result *[]string){
	visited[start] = true
	*result = append(*result, start)

	for _, neighbor := range graph[start]{
		if !visited[neighbor]{
			dfs9graph, neighbor, visited, result
		}
	}
}
func main(){
	graph := map[string][]string{
		"A": {"B", "C"},
		"B": {"D", "E"},
		"C": {"F"},
		"D": {"B"},
		"E": {"F", "G"},
		"F": {"E"},
		"G": {"E"},
	}
	startVertex := "A"
	visited := make(map[string]bool)
	var result []string
	Dfs(graph, startVertex, visited, &result)
}

//граф представлен матрицей смежности - квадратичная сложность
func Dfsnon(graph [][]int, start int, visited *[]bool, result *[]int){
	(*visited)[start] = true
	*result = append(*result, start)

	for v := 0; v < len(graph); v++{
		if graph[start][v] == 1 && (*visited)[v]{
			Dfsnon(graph, v, visited, result)
		}
	}
}
func Main() {
	graph := [][]int{
		{0, 1, 1, 0, 0, 0},
		{1, 0, 0, 1, 1, 0},
		{1, 0, 0, 0, 1, 1},
		{0, 1, 0, 0, 0, 0},
		{0, 1, 1, 0, 0, 1},
		{0, 0, 1, 0, 1, 0},
	}

	n := len(graph)
	visited := make([]bool, n)
	var result []int
	startVertex := 0//стартуем с вершины 0
	Dfsnon(graph, startVertex, &visited, &result)
}

//компонента связности - подмножество вершин графа, каждая вершина из одной группы связана с другими вершинами этой же группы
//цикл в неоринтированном графе - путь из вершины в неё же, при котором обходятся все ребра цикла


//обход в ширину - похоже на бинарное дерево

func Bfs(graph map[string][]string, start string) []string{
	visited := make(map[string]bool)
	queue := []string{start}
	var result []string

	for len(queue) > 0{
		//извлекаем 1 элемент из очереди
		vertex := queue[0]
		queue = queue[1:]
	}

	if !visited[vertex] {
		result = append(result, vertex)
		visited[vertex] = true
	}

	//добавляем непосещенных соcедей в очередь
	for _, neighbor := range graph[vertex]{
		if !visited[neighbor] {
			queue = append(queue, neighbor)
		}
	}
	return result
}