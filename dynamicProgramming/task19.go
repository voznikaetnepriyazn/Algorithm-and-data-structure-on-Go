package algs

//cell[i, j] = max(предыдущий максимум cell[i-1, j], или стоимость текущего элемента + стоимость оставшегося пространства cell[i-1, j - вес предмета])
//где i - строки, j - столбцы
//пример - числа фибоначчи, каждое последующее число равно сумме двух предыдущих - рекуррентное соотношение

//мемоизация - храниим предыдущие состояния

var dp1 = make(map[int]int)

func fib(n int) int {

	//O(1)
	if n < 2 {
		return n
	}
	if n == 2 {
		return 1
	}

	//O(1)
	if val, exists := dp1[n]; exists {
		return val
	}

	//в эту ветку мы попадаем один раз для каждого n
	dp1[n] = fib(n-1) + fib(n-2)
	return dp1[n]
}

func fibIterative(n int) int {
	dp1[1] = 1
	dp1[2] = 1
	for i := 3; i < n; i++ {
		dp1[i] = dp1[i-1] + dp1[i-2]
	}
	return dp1[n]
}

//рекуррентная формула - большие значения через меньшие
//каждое значение вычисляем один раз и запоминаем его в массиве или хэш-таблице
//O(n)
