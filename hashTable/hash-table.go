//O(1) - вставка, удаление, выборка

//построение хэш-функции [0; m-1]
//метод остатка от деления - h(k) = k%m, индекс в результате такого преобразования не выйдет за пределы m-1
//m - простое число, отличное от степени 2
//метод умножения - h(k) = m * (k*A)mod 1 - округляем до наименьшего целого
//А - вещественное число, константа 0<A<1, А*k - тоже вещественное, mod выделяет вещественную часть, A должно быть между 0 и 1Б чтобы было 
//максимально равномерное распределение между 0 и m-1, и округлить в наименьшую сторону, А = 0,618
//чтобы убрать ограничения на возможные значения m

//переполнение таблицы n/m - соотношение количества элементов и размера таблицы. Если значение стремится к 1 (0,75), то новая аллокация памяти

//коллизии - разным ключам хэш-функция выдаёт одинаковое значение, необходимо хранить пару ключ - значение
//метод цепочек - на каждое одинаковое значение создается связанный список, если список есть - значение дописывается в конец, О(n)
//метод открытой адрессации - при совпадении индексов храним значение в соседней ячейке

//открытая адресация - вставка
package algs
import (
	"fmt"
	"strconv"
	"strings"
	"math"
)
const(
	m = 10
	REMOVED = "REMOVED"
)

var T [m]string

func Insert(key,value string){
	for i := 0, i < m, i++{//h(v) для любых k находится в диапазоне [0, m-1]
		hash := (h(v) + i) % m //не превышает m
		if T[hash] == nil || T[hash] == REMOVED{
			T[hash] = value
			return
		}
	}
}

func h(key string) int{
	hash := 0
	for _, c := range key{
		hash += int(c)
	}
	return hash % m
}
//открытая адресация - выборка
const(
	m = 10
)

var T [m]string

func Get(key string){
	for i < m{
		hash := (h(v) + i) % m
	}
	if T[hash] != nil{
		if T[hash].key == key{
			return T[hash]
		}
		return nil
	}
}

func h(key string) int{
	hash := 0
	for _, c := range key{
		hash += int(c)
	}
	return hash % m
}

//открытая адресация - удаление
func Remove(key string){
	for i < m{
		hash := (h(v) + i) % m
	}
	if T[hash] != nil && T[hash] != REMOVED{
		if T[hash].key == key{
			T[hash] = REMOVED
		}
		return T[hash]
	}
}

const(
	m = 10
	REMOVED = "REMOVED"
)

var T [m]string

func h(key string) int{
	hash := 0
	for _, c := range key{
		hash += int(c)
	}
	return hash % m
}

//метод двойного хэширования - если ячейка k занята, рассматриваем h(k) + h1(k) % m, затем h(k) + 2*h1(k) % m
//h(k, i) = h(k) + i(номер попытки) * h1(k) % m

//необходимо ограничить применение коллизий